No,Category,Question,Acceptable Answers,,
1,Core Java,How to make a class immutable in java?,"Make sure the candiate says atleast 3-4 point below in any order:

Declare the class as final (so it can’t be extended.)
Make all fields private (so that direct access is not allowed.)
Don’t provide setter methods for variables.
Make all fields final (so that its value can be assigned only once).
Initialize all the fields via class constructor. Perform object cloning in the getter method to return a copy rather than returning the actual object reference",,
,Core Java,Is java “pass-by-value” or “pass-by-reference”,"Java is always pass by value, this means that it creates a copy of the contents of the parameters in memory. Object variables always refer to the memory heap’s real object.",,
2,Core Java,"What is difference between final, finally and finalize in Java?","Final:
final variables cannot be reassigned.
Final methods cannot be overridden.
Final classes cannot be extended.

Finally:
Used in exception handling.
Used with try-catch block.
Statements in finally always execute with or without an exception.

Finalize:
Finalize method is executed by Garbage Collector before the object is destroyed.",,
,,What is Garbage collection,"- used to free of memory, by disposing objects which do not have references or not used - invoked using System.gc",,
3,Core Java,"If two objects are equal according to equals() method,  will the hashcodes be same?",Yes. (It is guarantted to be same),,
4,Core Java,"If two objects has the same hashcode,  Should they be equal?",No (It is not guarantted to be same).  ,,
,String,Why is string used as key in hashmap?,"- Because string is immutable, its hashcode is cached at the time of creation and does not need to be calculated again - And its processing is faster than other hashmap key objects",,
,,How to prevent collision in hashMap,- Write a good hashing function to prevent collision,,
,,What if I have a customized object in my HashMap what do I need to do?,"- override the Hashcode and equals() - A simple rule is to use immutable objects as keys - If it were mutable, then the hashcode() value or equals() condition might change, and you would    never be able to retrieve the key from your HahMap",,
,,What is the difference between hashTable and HashMap,"HashMap - The method is not Synchronized - Not thread Safe - No waiting of thread so performance is high - Null is allowed for Both key and value HashTable - The method is Synchronized - Thread safe - Because there is waiting of thread, performance is low - Does not allow null key and values",,
,,What is the difference between hashTable and concurrentHashMap,"ConcurrentHashMap - applies locks only at bucket level called fragment while adding or updating the map - allows concurrent read and write operations in the map - allows null key and values - It is faster than Hashtable HashTable - It is a base implementation of Map interface - doesn’t allow null keys and values - applies lock on the entire collection - slower than concurrentHashMap  Both are synchronized in nature so that two different threads can’t access simultaneously And no order is maintained",,
,,"Difference Between ConcurrentHashMap and SynchronizedHashMap
","ConcurrentHashMap - ConcurrentHashMap is a class that implements the ConcurrentMap and serializable interface. - It locks some portion of the map. - allows performing concurrent read and write operation. Hence, performance is relatively better than the Synchronized Map - allow inserting null as a key or value. - doesn’t throw ConcurrentModificationException. SychronizedHashMap - We can synchronize the HashMap by using the synchronizedMap() method of java.util.Collections class. - It locks the whole map. - In Synchronized HashMap, multiple threads can not access the map concurrently. Hence, the performance is relatively less than the  ConcurrentHashMap. - Synchronized HashMap allows inserting null as a key. - Synchronized HashMap throw ConcurrentModificationException.",,
,,What is HashSet?,"- it constructs a collection that uses a hash table for storing elements - it inherits the abstractSet class and implements the Set interface - uses hashing to store elements, it uses HasMap internally in Java - It is achieved by storing elements as keys with the same value always",,
,,What is Thread safe?,"- thread-safe code in Java refers to code that can safely be utilized or shared in concurrent or multi-threading     environment and they will behave as expected.",,
,,Is hash map Thread Safe?,"No - If one thread does a put() on the hashmap it causes a structural change in the table which takes time,  if another thread performs a put() it may not get the new data of the table but an old values, here problem ensue -To correct this we can use mostly a concurrentHashMap",,
,,Difference between countdown latch and cyclic barrier,"Countdownlatch —> a construct that a thread waits on while other threads count down on the latch until it reaches zero - allows one or more threads to wait for a number of tasks to complete - maintains a count of tasks - cannot be reused, when count reaches zero it cannot be reset CyclicBarrier —> a reusable construct where a group of threads waits together until all the threads arrive at that point, the barrier is broken and an action can optionally be taken. - allows a number of threads to wait on each other - maintains a count of threads - can be reused after holding threads are released",,
,,What is Lock Interface,"- it is one of the most used interfaces in java.  - Available in Java.util.concurrent.locks used as a thread synchronization mechanism - it is more flexible and provides more options in comparison to the synchronized block ",,
,,Difference between Lock Interface and Synchronized Block,"There are a few differences between the lock and synchronized block that are given below.
Lock interface provides the guarantee of sequence in which the waiting thread will be given the access, whereas the synchronized block doesn't guarantee it.
Lock interface provides the option of timeout if the lock is not granted whereas the synchronized block doesn't provide that.
The methods of Lock interface, i.e., Lock() and Unlock() can be called in different methods whereas single synchronized block must be fully contained in a single method.",,
,,What are the states in the lifecycle of a Thread?,"A thread can have one of the following states during its lifetime:
New: In this state, a Thread class object is created using a new operator, but the thread is not alive. Thread doesn't start until we call the start() method.
Runnable: In this state, the thread is ready to run after calling the start() method. However, the thread is not yet selected by the thread scheduler.
Running: In this state, the thread scheduler picks the thread from the ready state, and the thread is running.
Waiting/Blocked: In this state, a thread is not running but still alive, or it is waiting for the other thread to finish.
Dead/Terminated: A thread is in terminated or dead state when the run() method exits.",,
,,What is the difference between a race condition and a deadlock,"A Race condition is a problem which occurs in the multithreaded programming when various threads execute simultaneously accessing a shared resource at the same time. The proper use of synchronization can avoid the Race condition.  Deadlock is a situation in which every thread is waiting for a resource which is held by some other waiting thread. In this situation, Neither of the thread executes nor it gets the chance to be executed. Instead, there exists a universal waiting state among all the threads. Deadlock is a very complicated situation which can break our code at runtime.",,
,,How to Avoid deadlocks,"- The solution is found at the roots, access the resources causing the issues - Re-order the statements where the code is accessing the shared resources  How to prevent deadlock - Avoid giving locks to multiple threads - Avoid unnecessary locks, only give locks to important threads - Use thread Join",,
,String,"What is Difference between String, and StringBuilder?","-String objects are immutable, Stringbuilder objects are mutable -String operations are thread-safe because of its immutability, string builder operations are not -Performance of string is slower than string builder in cases of concatenation -You can compare objects of string using the equals method, but cannot compare the objects to the strinbuilder using the equals methods",,
,String,"What is Difference between String, and StringBuffer?","-String objects are immutable, Stringbuffer objects are mutable -Performance of string is slower than Stringbuffer in cases of concatenation -You can compare objects of string using the equals method, but cannot compare the objects to the stringbuffer using the equals methods - String uses string pool to store object, the stringbuffer object is stored in the heap memory",,
6,String,What is Difference between StringBuffer and StringBuilder?,"StringBuffer operations are thread-safe and synchronized.
StringBuilder operations are not thread-safe.
StringBuilder performance is fast than StringBuffer because of no overhead of synchronization",,
,String,Is String Thread- Safe?,"Yes strings a thread safe because they are immutable once assigned they will behave the same through out the process, and can be used in multi-threading environment",,
,String,Intern,Used to copy string from heap memory to string pool,,
5,Core Java, What is the difference between equals() method and double equal operator (==) in Java?,"equals() method
This method is defined in the Object class in Java.
It is used for checking the equality of contents between two objects defined by business logic.

double equal operator (==)
it is a binary operator in Java.
It is used for comparing addresses (or references), i.e checks if both the objects are pointing to the same memory location.",,
7,Core Java,What is the base class of all exceptions in java?,Java.lang.Throwable or Throwable class.,,
8,Core Java,What is the Time complexity (or Big 'O' notation) for contains() method in ArrayList?,O(n) ,,
9,Core Java,What is the Time complexity (or Big 'O' notation) for get() method in Hashmap?,O(1),,
,,What is fail fast and fail safe,"- Fail safe means that during iteration iterators will not throw any exception even if the collection is modified   while iterating over it, while fail-fast throws an exception ( ConcurrentModificationException) if the    collection is modified while iterating over it. Fail Fast - Array, LinkedList Fail Safe - Concurrent hashMap",,
,Java 8,"What are new features were added in Java 8?
","	Lambda Expressions − lambda expression is a function that can be referenced and passed around as an object
	Method References − Method references are the references that use a function as a parameter to request a method.
	Optional − This class is to provide a type-level solution for representing optional values instead of using null references.
	Functional Interface – An Interface that contains exactly one abstract method and implementation can be provided using a Lambda Expression
	Default methods − give us the ability to add full implementations in interfaces besides abstract methods
	Stream API − Stream API provides a functional approach to processing collections of objects.
	Date and Time API − an improved, immutable JodaTime-inspired Date API
	Nashorn, JavaScript Engine − Java-based engine for executing and evaluating JavaScript code",,
10,Core Java /Java8,What is a functional inferface in java?,"it’s a java 8 feature. Introduced in java 8
Functional Interfaces is an interface with only one abstract method.
Defined using @FunctionalInterface annotation. This annotation is optional.
Functional interfaces are used in lambda expressions.

Also known as Single Abstract Method (SAM) interface",https://www.javaguides.net/2018/11/java-8-interview-questions-and-answers.html,
,,What is the advantage of Lambda function,"- Reduce the amount of code written -Readability -Elimination of shadow variables - Code reuse - Encouragement of functional coding",,
11,Core Java/Java 8,What is 'default' keyword in java with respect to methods?,"it’s a java 8 feature. Introduced in java 8
Default mehods can be defined in interfaces. Default methods have a body
Provides backward compability.
",,
,Java 8,"What is a method reference?
","- Method reference is used to refer method of the functional interface. It is a compact and easy form of a lambda expression.  - Each time when you are using a lambda expression to just referring a method, you can replace your lambda expression with a method reference.",,
,Java 8,"What are different kinds of Method References?
","- 	Reference to a static method. For example: ContainingClass::staticMethodName
- 	Reference to an instance method of a particular object. For example: containingObject::instanceMethodName - 	Reference to an instance method of an arbitrary object of a particular type. For example: ContainingType::methodName
-	Reference to a constructor. for example: ClassName::new


",,
12,REST,What are 'Idempotent' methods in REST?,"Method can be called multiple times safely and returns same result.
Example 'GET' HTTP method. 'POST' is not a idempotent because it generally changes the  state of the system.",,
13,REST,What are CRUD operations in REST?,"CRUD is a short form of Create, Read, Update and Delete.

the POST is used to create a resource,
 GET is used to read a resource, 
PUT is used to updated a resource and 
DELETE is used to remove a resource from the server.",,
14,Spring,What are some common design patterns used in spring?,"Check wheter the candidates say atleast 3 of them

    Singleton Pattern ( singleton-scoped beans) - Initialized on once in the application
    Factory Pattern  (Bean Factory classes)
    Prototype Pattern (prototype-scoped beans) - Will always create a new instance anytime
    Adapter Pattern (Spring Web and Spring MVC)
    Proxy Pattern  (Spring Aspect-Oriented Programming support)
    Template Method Pattern  (JdbcTemplate, HibernateTemplate)
    Front Controller  (Spring MVC DispatcherServlet)
    Model View Controller (Spring MVC)
",,
,,What is Inversion of Control,"- It creates the objects, configures and assembles their dependencies, manages their entire life cycle.  - The Container uses Dependency Injection(DI) to manage the components that make up the application.  - It gets the information about the objects from a configuration file(XML) or Java Code or Java Annotations and Java POJO class. These objects are called Beans.",,
,,What is the Difference Between Factory Pattern and Abstract Factory Pattern,"-The main difference between factory pattern and abstract factory pattern is that the factory pattern provides a method of creating objects without specifying the exact class used to create it while the abstract factory pattern provides a method to combine a group of individual factories without specifying their concrete classes. - The Factory method is a method, while the abstractFactory is an Object - The Factory pattern uses inheritance and relies on subclass to create the objects, while Abstract class uses composition to delegate responsibility of creating an object to another class",,
15,Core Java,"Difference between JVM, JRE, JDK","JVM - Java Virtual Machine, abstract machine that provides the runtime environment to execute java byte code
- It is a specification which specifies the working of JVM - Has three notations : Specifications, Implementation and Runtime Instance  JRE - Java Runtime Environment, it is the implementation of the JVM - This sis a runtime environment where java byte code can be executed - contains a set of libraries and tools used by the JVM at runtime  JDK - Java Development Kit is a software tools used in developing Java applications - it contains JRE + development tools",,
,,"ClassPath, Normal Path","- ClassPath is used by JVM to find library files - Normal Path used by command prompt to find binary files",,
,,What ClassLoader,- Class loaders are responsible for loading Java classes dynamically to the JVM (Java Virtual Machine) during runtime. ,,
,,Types of class Loaders in Java,"Three built in classloaders are: - Bootstrap —> loads rt.jar and other classes e.g java.lang - Extensions —> It loads the extension of standard core Java classes from JDK extensions directory - Systems —> Loads classes from the current class path in the env variables",,
,,Types of memory allocated to JRE,"- Class / Method Area, Heap, Stack, Native Method Stack, Program Counter register",,
,,What is Heap Memory and Stack Memory,"	Heap memory is used by all the parts of the application whereas    stack memory is used only by one thread of execution.
	Whenever an object is created, it’s always stored in the Heap space and stack memory contains the reference to it.    Stack memory only contains local primitive variables and reference variables to objects in heap space.
	Objects stored in the heap are globally accessible whereas stack memory can’t be accessed by other threads.
	Memory management in stack is done in LIFO manner whereas it’s more complex in Heap memory because it’s used globally.    Heap memory is divided into Young-Generation, Old-Generation etc, more details at Java Garbage Collection.
	Stack memory is short-lived whereas heap memory lives from the start till the end of application execution.
	We can use -Xms and -Xmx JVM option to define the startup size and maximum size of heap memory.    We can use -Xss to define the stack memory size.
	When stack memory is full, Java runtime throws java.lang.StackOverFlowError    whereas if heap memory is full, it throws java.lang.OutOfMemoryError: Java Heap Space error.
	Stack memory size is very less when compared to Heap memory.    Because of simplicity in memory allocation (LIFO), stack memory is very fast when compared to heap memory.
",,
,,Just In time Compiler,"Compiles parts of the byte code with similar functionality at same time, hence reduces amount of time needed  for compilation",,
,,What is purpose of static methods and variables,"-The methods or variables defined as static are shared among all the objects of the class. - It is part of the class and not the object, does not need to be instantiated to access such variable or method - used to define a common method or variable across different objects of the class",,
,,Object Oriented Paradigm,"-Programming paradigm based on objects having data and methods based on class in which they belong. - Incorporates the advantages of modularity and reusability. - Instances of classes which interacts with one another to design a program",Object: real time entity having state & behavior,
,,What is Saga Pattern,"The Saga pattern is a failure management pattern that helps establish consistency in distributed applications and coordinates  transactions between multiple micro services to maintain data consistency.  The Saga architecture pattern provides transaction management using a sequence of local transactions. - A local transaction is the unit of work performed by a saga participant. - Every operations that is part of the Saga can be rolled back by a compensating transaction. - Saga pattern guarantees that either all operations complete successfully or    the corresponding compensation transactions are run to undo the work previously completed  There are two approaches to implement Saga pattern Choreography - Each micro service that is part of the transaction publishes an event that is processed by the next micro service. - Decision need to be made on which micro service will be part of the Saga. - Appropriate framework needs to be used to implement Saga - Saga Execution Coordinator (SEC) is either embedded within the microservice or can be standalone component. - Flow is successful if all the micro services complete their local transaction, and one of the micro-services reported any failure. - In the event of a failure, the microservice reports the failure to SEC, and it is then SEC’s responsibility to invoke the relevant    compensation transactions. - Works for Greenfield micro service application development Frameworks: Axon Saga (Spring Boot), Eclipse MicroProfile LRA, Eventuate Tram Saga, Seata  Orchestration - A single orchestrator is responsible for managing the overall transaction status - If any of the micro services encounter a failure, the orchestrator is responsible for invoking the necessary compensating transactions. - Useful fro brownfield micro service application development architecture —  in other words, this pattern works when we already    have a set of micro services and would like to implement the Saga pattern in the application. E.g Camunda, Apache Camel  ",,
,,What is AtomicInteger ,"- Provides operations on underlying int value that can be read and written atomically, and also contains advanced atomic operations. - Supports atomic operations on underlying int variable - Have get and set methods that work like reads and writes on volatile variables.",,
,,How to implement Circuit Breaker Pattern in Java Spring Boot,"- Spring cloud circuit Breaker library provides an implementation of the circuit breaker pattern - If failures build up to certain threshold Spring Cloud Circuit Breaker opens the circuit so that subsequent calls automatically fail,   the circuit is open, it redirects calls to the method, and they are passed on to our specified fallback method. Steps - Using resilence4j add to class path pom.xml file - Build the application using maven or gradle - Spring Cloud Circuit Breaker provides and interface called “ReactiveCircuitBreakerFactory” which has a method “create""  used to create new circuit breakers - Then we call run which takes a Mono or Flux and an optional Function (acts as fallback if anything goes wrong) ",,
,,How to change Tomcat to Jetty in Microservice,"- After creating the spring application, go the the POM.xml file and locate Spring-starter-web dependency - Inside the dependency create exclusion tag and put the TomCat dependency inside the tag, because Tomcat is the default server - Then copy the dependency of the Jetty server into the POM.xml file, then run your application",,
,,Singleton class in Java,"- class whose one instance can be created at any given time - it is used to control access to resources, such as database connections or sockets How to create Singleton - class can be made singleton by making its constructor private. - Provide a global static method that returns reference to the instance - The instance is stored as a private static variable",,
,,How to Break Singleton Property,"Refelection - by getting the declared constructor of the instance, and then set accessibility to true - enums can be used to overcome the reflection Serialization - used to convert an object of a byte stream and save to a file or send over a network - it is done by serializing the object of a singleton class then deserialize the object, this will break the singleton pattern by creating a new instance - it canoe overcome by implementing the method readResolve() Cloning - by creating a copy of the singleton object, there would be two copies hence the class is no more singleton -  To overcome this issue, override clone() method and throw an exception from clone method that is CloneNotSupportedException",,
,,Explain “Double Brace Initialization”,"The first brace is used to create anonymous inner class,  the second is an initialization block,  it is generally used to initialize collections",,
,,Marker Interface,"-Defined as an interface with no data member functions, I.e an empty interface e.g Serializable and clone able",,
,Servlets,What is Servelets?,"- It is a server side technology to extend the capability of web servers by providing support for dynamic response     and data persistence. - must implement the Java.servlet interface, httpServlet class provides methods, such as doGet() and doPost(),     for handling Http-specific services. ",,
,,Request Dispatch,"-Used to forward request that can be used by another resource like HTML, JSP or another servlet in same application - Can be used to include the content of another resource to the response.",,
,,Lifecycle of Servlet ,Loading - Instantiation - Initializaton - Request - Destruction,,
,,Session Management,"- A conversational state between client and server and consists of multiple request and response between client and server - To maintain session unique information is passed between server and client. - common ways include: UserAuthentication, Html Hidden field, Cookies, URL Rewriting, Session Management API",,
,JDBC,What is JDBC Driver,- This is a software component that enables java application to interact to with database,,
,Spring,Explain Bean,"- Beans are objects that form the backbone of Spring application. - It is an object that is instantiated, assembled and managed by a Spring IOC container",,
,,Autowiring,"- Enables the injection of. Bean automatically, don’t need to write explicit injection logic",,
,,How to integrate Spring and Hibernate,"- Spring ORM is used to integrate Spring and Hibernate - Spring ORM provides support for using declarative transaction management",,
,,Types os transaction management,"- Programatic Transaction Management, uses help of programming, provides extreme flexibility - Declarative transaction management, transaction management is separated from business code,     Only annotations or XML based configurations are used to manage transactions",,
,Spring,Different types of Autowiring,"-No : means auto wiring is off - byName: Injects the object dependency according to name of the bean, has same property and bean name - byType:  Injects the object dependency according to type, can have different property and bean name - constructor : By calling the constructor of the class - Autodetect: Tries by constructor if it fails tries by Type",,
,,What is a qualifier,- Used to indicate which bean to inject when different class has same interface implementation,,
,,What is @RestcontrollerAdvice,"-it is specialization of @Component annotation so that it is auto-detected via classpath scanning.   It is used with @ExceptionHandler, @ResponsStatus",,
,,What is Profile,- Used to help segregate application configurations to inject environment-specific configurations without changing the application,,
,Hibernate,What is Hibernate,"- It is java based ORM tool that provides a framework for mapping application domain objects to the relational    database tables and vice versa - Provides reference implementation of Java Persistence API, making it a great choice for ORM tool with benefit    of loose coupling. - Map POJO to traditional database tables ",,
,,Importance of Hibernate,"- Eliminates boiler plate code from JBDC and takes care of managing resources - Provides support for XML and JPA annotations , making the code implementation independent - provides powerful query language (HQL) similar to SQL - Open source - Easy to integrate with Java EE frameworks",,
,Exception,Difference between Error Exception,"Error - It is an irrecoverable condition occurring at runtime - though can be caught in catch block but the execution of application will come to a halt and is not recoverable  Exception - conditions that occur because of bad input or human error - It is possible to recover from an exception",,
,,What is the response of classNotFoundException during compile time and runtime,"ClassNotFoundException is an exception that occurs when you try to load a class at run time  using Class.forName() or loadClass() methods and mentioned classes are not found in the classpath.
NoClassDefFoundError is an error that occurs when a particular class is present at compile time, but was  missing at run time.
",,
,,ArrayStoreException,A Runtime exception which occurs when an attempt is made to store wrong data type in an array,,
,Micro-services,What is Microservice,"- it is an architectural style that structures an application as a collection of small autonomous services,  modeled around a business domain. Each service is self-contained and implements a single business capability",,
,,Principles used to Design Microservice Architecture,"- Independent and Autonomous Service - Scalability - Decentralization - Resilient Services - Real-Time Load Balancing - Availability - Continuous delivery through DevOps Integration - Seamless API Integration and Continuous Monitoring - Isolation from Failures - Auto-Provisioning ",,
,,Design Patterns of Microservices,"- Aggregator : involves getting input from different services combining them to produce an output, based    on DRY - API gateway : act as an aggregator variation, can send request to multiple services and similarly aggregate    the result    back to the composite or consumer service. Can be by HTTP request or message bus -  Chain of Responsibility: Produces a single output which is a combination of multiple chained output uses     Synchronous HTTP request or response - Asynchronous Messaging Design: This is a form of chain pattern where there is no blocker all the services can    communicate with each other but not sequentially - Database or Shared Data Pattern: Each service can have different database thereby not allowing another to     share the same database - Event Sourcing Design Pattern: The event sourcing design pattern creates events regarding the changes in the   application state. Also, these events are stored as a sequence of events to help the developers track which    change was made when. - Branch Pattern: is a design pattern in which you can simultaneously process the requests and responses from     two or more independent microservices. So, unlike the chained design pattern, the request is not passed in a    sequence, but the request is passed to two or more mutually exclusive microservices chains. - Command Query Responsibility Segregator (CQRS) Design Pattern - Circuit Breaker Pattern:  the Circuit Breaker design pattern is used to stop the process of request and    response if a service is not working.  - Decomposition Deign Pattern: to decompose a small or big application into small services, you can use    the Decomposition patterns. - Strangler or Vine Pattern",,
,,How to integrate external API in spring boot,- By using RestTemplate from spring web client then use the method getForObject to consume the uri,,
,Java,Autoboxing or Unboxing,"- This is the automatic conversion that the java compiler makes between primitive data types and object    wrapper classes.",,
,Serialization,What is Serialization,- This is the process of converting an object into a byte stream ,,
,,What is Transient and when to use it,"- To make a variable not serialized in a serializable class  - E.G if you don’t want to convert a password to byte stream",,
,,How to prevent a child class from being serialized?,"- The best way is to implement writeObject() and readObject() method in the child class and throw    NotSerializableException from those methods.",,
,,What do we use SerialVersionUID,"we use the serialVersionUID attribute to remember versions of a Serializable class to verify that a loaded class  and the serialized object are compatible.",,
,Thread,Difference between executor.execute and executor.submit,"Executor.execute - Declared in the Executor interface - can only accept Runnable Task - Returns void Executor.submit - Declared in ExecutorService interface - Accept both Callable and Runnable - Returns Future objects",,
,Docker,How do you scale your application on docker,- By adding more apache nodes to cater for increased web traffic,,
,Exceptions,TryWithResources,"- Allows us to declare resources to be used in a try block with the assurance that the resources will  be closed after the execution of that block",,
,,What is the Comparator and comparable ,"Comparable: - Provides a single sorting sequence, sort the collection on the basis of a single element such as id, name, price - Affects the original class I.e actual class is modified - provides compareTo() method to sort element - present in java.lang - can be used to sort list e.g Collections.sort(List) Comparator -Provides multiple sorting sequences  - does not affect the original class - present in java.util - can be sorted using Collections.sort(List, Comparator) method",,
,,Differece between Iterator and Listierator,"Iterator - used to traverse all collections object - traverse only forward Listerator - used to traverse list alone - traverse forward and backward direction",,
,,Difference between Vector and ArrayList,"-- ArrayList is non-synchronized, vector is synchronized - ArrayList increments 50% of its current  size if element added exceeds its capacity,    while vector increases 100% of its current size. - Arraylist is not a Legacy, Vector Legacy class - ArrayList is Faster, LinkedList is slower - ArrayList uses iterator interface to traverse through element, Vector uses both iterator and enumerator",,
,,Difference between LinkedList and ArrayList,"ArrayList - internally uses a dynamic array to store data - Manipulation is slow, need to shift all data if an element is removed - good for storing data - can act as a list cos it implements list interface - contiguous memory location - default capacity of 10 is allocated at initialization LinkedList - internally uses a doubly linked list to store data - Manipulation is faster in linked list - good for manipulating data - acts as a list and queue because it implements list and dequeue interface - not contiguous memory location - No default capacity is allocated",,
,,What is the difference between pathVariable and RequestParam,"- RequestParam is used for query data - returns no exception if variable is not found  - PathVariable will return 404 error if variable is not found",,
,Stream,What is the Difference between Stream and Collections,"- Collections are used to store and group data in a particular data structure such as List, Set or Map, while Stream is used to perform complex operation such as Filtering, Mapping or Matching of the stored data structure - Collections allows adding or removing of element, Streams does not allow adding or removing elements - Streams can perform iterations internally, while collections will need external iterations - Streams are only traversed only once, while collections can be traversed multiple times",https://www.javaguides.net/2021/11/java-stream-api-interview-questions-and-answers.html,
,Stream,What is a stream,- Stream is a sequence of objects that supports various methods and can be pipelined to produce desired results,,
,Stream,What is Flatmap,- It is an intermediate function in stream used to transform and flatten more than one collection into a single stream,,
,Stream,Difference between intermediate and Terminal function,"- in intermediate function you can perform additional functions after its been used e.g, map, filter, flattop.  For terminal functional you cannot perform additional operation after its used e.g foreach, collect, min, max",,
,Stream,What is difference between Parallel stream and normal Stream,"Sequential Stream - is one whose elements are processed sequential when the stream pipeline is executed by a single thread - non parallel streams that use a single thread to process the pipeline - Not explicitly specified as parallel - Do not take the advantage of the multi-core system even though the underlying system supports parallel    execution - Output is predictable Parallel Stream - is split into multiple sub streams that are processed in parallel by multiple instances of the stream pipeline being executed by multiple threads - Their intermediate results can be combined to create the final results. - invoked by using collection.parallelStream() - Primary reason is to improve performance - Output is not predictable",,
,,What is the difference between PermGen and MetaSpace,"PermGen (Permanent Generation)  - Is a special heap space separated from the main memory heap. - the JVM stores all the static content in this memory section - it contains data about bytecode, names, and JIT information. - With its limited memory size, PermGen is involved in generating the famous OutOfMemoryError.  Metaspace  - is a new memory space – starting from the Java 8 version;  - it has replaced the older PermGen memory space. - this native memory region grows automatically by default. - The garbage collector now automatically triggers the cleaning of the dead classes once the class     metadata usage reaches its maximum metaspace size.",,
,,What are SOLID Principle,"S - Single-Responsiblity —> this states that a class should have only one reason to change, this means it should have only one job to do O - Open-closed Principle —> This means that your code should be open for extension but not modify the source code L - Liskov substitution principle —> This principle states that objects of a superclass should be substituted with objects of the subclasses                                                                 without breaking the application or cause an error I - Interface Segregation Principle —> states that a client should not be forced to implement the interface it does not need,                                                                     or the method it do not use D - Dependency Inversion —> This states that high level modules should import properties from low-level modules but rather                                                         depend on abstractions",,